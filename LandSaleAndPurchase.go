package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"math/rand"
	"strconv"
	"time"
)

type SimpleChaincode struct {
}

type OWNER_ID_Holder struct {
	OWNER_IDs []string `json:"OWNER_IDs"`
}

//Information to be stored about land in blockchain network
type Address struct {
	LandId  string `json:"landId"`
	Plotno  string `json:"plotno"`
	City    string `json:"City"`
	Area    string `json:"area"`
	Pincode string `json:"Pincode"`
}

type Owner struct {
	Id           int    `json:"id"` //generated by blockchain
	UserName     string `json:"userName"`
	Password     string `json:"password"`
	FirstName    string `json:"firstName"`
	LastName     string `json:"lastName"`
	AadharNumber string `json:"aadharNumber"`
}

func main() {

	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		fmt.Printf("Error starting Simple chaincode: %s", err)

	}
}

//Init
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {

	var ownerIds OWNER_ID_Holder

	bytes, err := json.Marshal(ownerIds)

	if err != nil {
		return nil, errors.New("Error creating OWNER_ID_Holder record")
	}

	err = stub.PutState("owner_Ids", bytes)

	return nil, nil

}

func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {

	if function == "createOwner" {

		return createOwner(stub, args)
	}
	if function == "createProperty" {

		return createProperty(stub, args)
	}
	if function == "transferOwnerShip" {

		return transferOwnerShip(stub, args)
	}

	return nil, nil
}

func (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {

	if function == "listRegisteredProperties" {

		return listRegisteredProperties(stub, args)
	}
	if function == "listRegisteredPropertiesByCity" {

		return listRegisteredPropertiesByCity(stub, args)
	}
	if function == "listRegisteredPropertiesByCityAndArea" {

		return listRegisteredPropertiesByCityAndArea(stub, args)
	}
	if function == "listRegisteredPropertiesByPincode" {

		return listRegisteredPropertiesByPincode(stub, args)
	}
	if function == "listRegisteredOwners" {

		return listRegisteredOwners(stub, args)
	}
	if function == "listpropertyHistory" {

		return listpropertyHistory(stub, args)
	}
	if function == "getOwnerById" {

		return getOwnerById(stub, args)
	}

	if function == "getIds" {

		return getIds(stub, args)
	}

	return nil, nil

}

func getOwnerById(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {

	bytes, err := stub.GetState(args[0])

	if err != nil {
		return nil, err
	}
	return bytes, nil

}

func getIds(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {

	bytes, err := stub.GetState("owner_Ids")

	if err != nil {
		return nil, err
	}
	return bytes, nil

}

func listRegisteredOwners(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
	fmt.Println("Inside list generated Users")

	bytes, err := stub.GetState("owner_Ids")

	fmt.Println("Ids recieved", string(bytes))
	var ownerIDHolder OWNER_ID_Holder
	err = json.Unmarshal(bytes, &ownerIDHolder)

	result := "["

	var temp []byte
	var o Owner

	for _, own := range ownerIDHolder.OWNER_IDs {

		fmt.Println("Inside for loop for getting Owner. Owner Id is  ", own)

		o, err = retrieveOwner(stub, own)

		temp, err = json.Marshal(o)

		if err == nil {
			result += string(temp) + ","
		}

	}

	if len(result) == 1 {
		result = "[]"
	} else {
		result = result[:len(result)-1] + "]"
	}

	return []byte(result), nil
}

func retrieveOwner(stub shim.ChaincodeStubInterface, ownerId string) (Owner, error) {

	fmt.Println("Inside retrieve Owner")

	var o Owner

	bytes, err := stub.GetState(ownerId)

	fmt.Println("Owner Id is ", ownerId, "and owner details are ", string(bytes))

	if err != nil {
		return o, errors.New("Owner not found")
	}

	err = json.Unmarshal(bytes, &o)

	return o, nil

}

func createOwner(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {

	fmt.Println("Inside create user")

	ownerDetails := Owner{}

	ownerDetails.FirstName = args[0]
	ownerDetails.LastName = args[1]
	ownerDetails.AadharNumber = args[2]
	ownerDetails.UserName = args[3]
	ownerDetails.Password = args[4]

	ownerDetails.Id = generateUserId()

	ownerDetailBytes, err := json.Marshal(ownerDetails)

	fmt.Println("Owner Details are : ", string(ownerDetailBytes))

	if err != nil {
		return nil, errors.New("Problem while saving Owner Details in BlockChain Network")

	}

	var id = strconv.Itoa(ownerDetails.Id)

	err = stub.PutState(id, ownerDetailBytes)

	//now owner has been added to block chain network, now we have to save the  Id as well

	bytes, err := stub.GetState("owner_Ids")

	var newOwnerId OWNER_ID_Holder

	err = json.Unmarshal(bytes, &newOwnerId)

	if err != nil {
		return nil, errors.New("error unmarshalling new Owner Id")
	}

	newOwnerId.OWNER_IDs = append(newOwnerId.OWNER_IDs, id)

	bytes, err = json.Marshal(newOwnerId)

	if err != nil {

		return nil, errors.New("error marshalling new Owner Id")
	}

	err = stub.PutState("owner_Ids", bytes)
	fmt.Println("Owner Id Saved is ", string(bytes))

	if err != nil {
		return nil, errors.New("Unable to put the state")
	}

	return nil, nil
}

func generateUserId() int {

	min := 1
	max := 1000

	rand.Seed(time.Now().Unix())
	return (rand.Intn(max-min) + min)

}

func createProperty(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {

	return nil, nil
}
